import _JSON$stringify from 'babel-runtime/core-js/json/stringify';
import _getIterator from 'babel-runtime/core-js/get-iterator';
import _typeof from 'babel-runtime/helpers/typeof';
import _Object$getPrototypeOf from 'babel-runtime/core-js/object/get-prototype-of';
import _classCallCheck from 'babel-runtime/helpers/classCallCheck';
import _createClass from 'babel-runtime/helpers/createClass';
import _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';
import _inherits from 'babel-runtime/helpers/inherits';
import React from 'react';
import PropTypes from 'prop-types';
import javascript_time_ago from 'javascript-time-ago';
import shallow_compare from 'react-addons-shallow-compare';

var global_scope = typeof window !== 'undefined' ? window : global;

var React_time_ago = function (_React$Component) {
	_inherits(React_time_ago, _React$Component);

	function React_time_ago(props, context) {
		_classCallCheck(this, React_time_ago);

		var _this = _possibleConstructorReturn(this, (React_time_ago.__proto__ || _Object$getPrototypeOf(React_time_ago)).call(this, props, context));

		var locale = props.locale,
		    date_time_format = props.date_time_format,
		    update_interval = props.update_interval;

		// If `locale` was not explicitly set
		// then try to derive it from `react-intl` context

		if (!locale) {
			// supports `react-intl`
			if (context.intl) {
				locale = context.intl.locale;
			}
		}

		// If no locale is set, then throw an error
		if (!locale) {
			throw new Error('No locale specified for react-time-ago');
		}

		// `_react_time_ago` holds cached formatters
		// and the global refresh timer
		if (!global_scope._react_time_ago) {
			create_react_time_ago(update_interval);
		}

		// Take `javascript-time-ago` formatter and 
		// `Intl.DateTimeFormat` verbose formatter from cache
		_this.time_ago = new Time_ago(locale);
		_this.date_time_formatter = new Date_time_formatter(locale, date_time_format);
		return _this;
	}

	_createClass(React_time_ago, [{
		key: 'shouldComponentUpdate',
		value: function shouldComponentUpdate(nextProps, nextState) {
			return shallow_compare(this, nextProps, nextState);
		}
	}, {
		key: 'componentDidMount',
		value: function componentDidMount() {
			var tick = this.props.tick;


			if (tick) {
				this.register();
			}
		}
	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			var tick = this.props.tick;


			if (tick) {
				this.unregister();
			}
		}
	}, {
		key: 'render',
		value: function render() {
			var _props = this.props,
			    children = _props.children,
			    wrapper = _props.wrapper,
			    time_style = _props.time_style,
			    timeStyle = _props.timeStyle,
			    style = _props.style,
			    className = _props.className;


			if (!children) {
				throw new Error('You are required to specify either a timestamp (in milliseconds) or Date as a child of react-time-ago component');
			}

			var full_date = this.full_date(children);

			var date = children instanceof Date && children;
			var time = typeof children === 'number' && children;

			var markup = React.createElement(
				'time',
				{
					dateTime: (date || new Date(time)).toISOString(),
					title: wrapper ? undefined : full_date,
					style: style,
					className: className },
				this.time_ago.format(time || date, time_style || timeStyle)
			);

			if (wrapper) {
				return React.createElement(wrapper, { verbose: full_date }, markup);
			}

			return markup;
		}

		// Verbose date string.
		// Is used as a tooltip text.
		//
		// E.g. "Sunday, May 18th, 2012, 18:45"
		//

	}, {
		key: 'full_date',
		value: function full_date(input) {
			if (this.props.full) {
				return this.props.full(input);
			}

			var date = void 0;

			if (input.constructor === Date) {
				date = input;
			} else if (typeof input === 'number') {
				date = new Date(input);
			} else {
				throw new Error('Unsupported react-time-ago input: ' + (typeof input === 'undefined' ? 'undefined' : _typeof(input)) + ', ' + input);
			}

			return this.date_time_formatter.format(date);
		}
	}, {
		key: 'register',
		value: function register() {
			global_scope._react_time_ago._register(this);
		}
	}, {
		key: 'unregister',
		value: function unregister() {
			global_scope._react_time_ago._unregister(this);
		}
	}]);

	return React_time_ago;
}(React.Component);

React_time_ago.propTypes = {
	locale: PropTypes.string,
	children: PropTypes.oneOfType([PropTypes.instanceOf(Date), PropTypes.number]),
	// `javascript-time-ago` relative time formatting style
	time_style: PropTypes.any,
	timeStyle: PropTypes.any,
	// (optional) Tooltip date formatter
	full: PropTypes.func,
	// Intl.DateTimeFormat options
	date_time_format: PropTypes.object,
	update_interval: PropTypes.number,
	wrapper: PropTypes.func,
	tick: PropTypes.bool.isRequired,
	style: PropTypes.object,
	className: PropTypes.string
};
React_time_ago.defaultProps = {
	// Thursday, December 20, 2012, 7:00:00 AM GMT+4
	date_time_format: {
		weekday: 'long',
		day: 'numeric',
		month: 'long',
		year: 'numeric',
		hour: 'numeric',
		minute: '2-digit',
		second: '2-digit'
	},

	// Updates once a minute
	update_interval: 60 * 1000,

	tick: true
};
React_time_ago.contextTypes = {
	intl: PropTypes.object
};
export default React_time_ago;


function start_relative_times_updater(update_interval) {
	function update_relative_times(dry_run) {
		if (!dry_run) {
			var _iteratorNormalCompletion = true;
			var _didIteratorError = false;
			var _iteratorError = undefined;

			try {
				for (var _iterator = _getIterator(global_scope._react_time_ago._components), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
					var component = _step.value;

					component.forceUpdate();
				}
			} catch (err) {
				_didIteratorError = true;
				_iteratorError = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion && _iterator.return) {
						_iterator.return();
					}
				} finally {
					if (_didIteratorError) {
						throw _iteratorError;
					}
				}
			}
		}

		global_scope._react_time_ago._timer = setTimeout(update_relative_times, update_interval);
	}

	update_relative_times(true);
}

function stop_relative_times_updater() {
	if (global_scope._react_time_ago._timer) {
		clearTimeout(global_scope._react_time_ago._timer);
		global_scope._react_time_ago._timer = undefined;
	}
}

function create_react_time_ago(update_interval) {
	var _react_time_ago = {
		_components: [],
		_register: function _register(component) {
			this._components.push(component);

			// If it's the first relative time component,
			// start periodical time refresh.
			if (this._components.length === 1) {
				start_relative_times_updater(update_interval);
			}
		},
		_unregister: function _unregister(component) {
			remove_element_from_array(this._components, component);

			// If it was the last relative time component,
			// stop periodical time refresh.
			if (this._components.length === 0) {
				stop_relative_times_updater();
			}
		},
		_destroy: function _destroy() {
			var _iteratorNormalCompletion2 = true;
			var _didIteratorError2 = false;
			var _iteratorError2 = undefined;

			try {
				for (var _iterator2 = _getIterator(this._components), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
					var component = _step2.value;

					this._unregister(component);
				}
			} catch (err) {
				_didIteratorError2 = true;
				_iteratorError2 = err;
			} finally {
				try {
					if (!_iteratorNormalCompletion2 && _iterator2.return) {
						_iterator2.return();
					}
				} finally {
					if (_didIteratorError2) {
						throw _iteratorError2;
					}
				}
			}

			delete global_scope._react_time_ago;
		}
	};

	global_scope._react_time_ago = _react_time_ago;
}

function remove_element_from_array(array, element) {
	var index = array.indexOf(element);
	if (index >= 0) {
		array.splice(index, 1);
	}
	return array;
}

export var Date_time_formatter = function () {
	function Date_time_formatter(locale) {
		var date_time_format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : React_time_ago.defaultProps.date_time_format;

		_classCallCheck(this, Date_time_formatter);

		// Formatters
		if (!global_scope._date_time_formatters) {
			global_scope._date_time_formatters = {};
		}

		// Formatters for this locale
		if (!global_scope._date_time_formatters[locale]) {
			global_scope._date_time_formatters[locale] = {};
		}

		// `Intl.DateTimeFormat` format caching key
		var date_time_format_id = _JSON$stringify(date_time_format);

		// Cache `Intl.DateTimeFormat` for this locale
		if (!global_scope._date_time_formatters[locale][date_time_format_id]) {
			global_scope._date_time_formatters[locale][date_time_format_id] = new Intl.DateTimeFormat(locale, date_time_format);
		}

		this.formatter = global_scope._date_time_formatters[locale][date_time_format_id];
	}

	_createClass(Date_time_formatter, [{
		key: 'format',
		value: function format(date) {
			return this.formatter.format(date);
		}
	}]);

	return Date_time_formatter;
}();

export var Time_ago = function () {
	function Time_ago(locale) {
		_classCallCheck(this, Time_ago);

		// Formatters
		if (!global_scope._time_ago_formatters) {
			global_scope._time_ago_formatters = {};
		}

		// Cache `javascript-time-ago` formatter for this locale
		if (!global_scope._time_ago_formatters[locale]) {
			global_scope._time_ago_formatters[locale] = new javascript_time_ago(locale);
		}

		this.formatter = global_scope._time_ago_formatters[locale];
	}

	_createClass(Time_ago, [{
		key: 'format',
		value: function format(date, time_style) {
			return this.formatter.format(date, this.parse_time_ago_style(time_style));
		}
	}, {
		key: 'parse_time_ago_style',
		value: function parse_time_ago_style(time_style) {
			if (!time_style) {
				return;
			}

			if (typeof time_style === 'string') {
				if (!this.formatter_styles[time_style]) {
					this.formatter_styles[time_style] = this.formatter.style[time_style]();
				}

				return this.formatter_styles[time_style];
			} else if ((typeof time_style === 'undefined' ? 'undefined' : _typeof(time_style)) === 'object') {
				return time_style;
			} else {
				throw new Error('Unknown time formatter style: ' + time_style);
			}
		}
	}]);

	return Time_ago;
}();
//# sourceMappingURL=react time ago.js.map